<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>运输层 | 可以刻意客气</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近在自学计算机网络自顶向下，本人将所学知识点整理如下，方便复习及构建自己的知识框架体系，并且加入了相关章节在互联网面试过程中的涉及到的考点。本章的主要内容是运输层，共分为七小节。   1 概述和运输层服务 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（logic communication）功能，它只工作在端系统中，将来自应用进程">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://yoursite.com/2020/03/12/%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="可以刻意客气">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近在自学计算机网络自顶向下，本人将所学知识点整理如下，方便复习及构建自己的知识框架体系，并且加入了相关章节在互联网面试过程中的涉及到的考点。本章的主要内容是运输层，共分为七小节。   1 概述和运输层服务 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（logic communication）功能，它只工作在端系统中，将来自应用进程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Bryce-HJ/IMG/raw/master/IMG/UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://github.com/Bryce-HJ/IMG/raw/master/IMG/SR%E5%8F%91%E9%80%81%E6%96%B9.png">
<meta property="og:image" content="https://github.com/Bryce-HJ/IMG/raw/master/IMG/SR%E6%8E%A5%E6%94%B6%E6%96%B9.png">
<meta property="og:image" content="https://github.com/Bryce-HJ/IMG/raw/master/IMG/TCP%E6%8A%A5%E6%96%87%E6%AE%B5.png">
<meta property="article:published_time" content="2020-03-12T00:01:38.000Z">
<meta property="article:modified_time" content="2020-03-13T03:47:04.990Z">
<meta property="article:author" content="郝靖">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Bryce-HJ/IMG/raw/master/IMG/UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">可以刻意客气</div>
      
        <div id="subtitle">积极求知的生活记录</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">可以刻意客气</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="yoursite.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-运输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/%E8%BF%90%E8%BE%93%E5%B1%82/" class="article-date">
  <time datetime="2020-03-12T00:01:38.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      运输层
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;最近在自学计算机网络自顶向下，本人将所学知识点整理如下，方便复习及构建自己的知识框架体系，并且加入了相关章节在互联网面试过程中的涉及到的考点。本章的主要内容是运输层，共分为七小节。  </p>
<h2 id="1-概述和运输层服务"><a href="#1-概述和运输层服务" class="headerlink" title="1 概述和运输层服务"></a>1 概述和运输层服务</h2><ul>
<li>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（logic communication）功能，它只工作在端系统中，将来自应用进程的报文移动到网络边缘（即网络层）。<font color=#DC143C>值得注意的是：</font>网络层提供了主机之间的逻辑通信，而运输层为运行在主机上的进程之间提供了逻辑通信。</li>
<li>TCP/IP网络为应用层提供了两种运输层协议，一种是<font color=#FFD700>UDP（用户数据协议，Uesr Data protocol）,</font>它提供了一种不可靠、无连接的服务；一种是<font color=#FFD700 >TCP（传输控制协议，Transmission Control Protocol）,</font>它提供了一种可靠的、面向连接的服务。</li>
<li>UDP和TCP最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。</li>
</ul>
<h2 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2 多路复用和多路分解"></a>2 多路复用和多路分解</h2><ul>
<li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<font color=#DC143C>多路复用（multiplexing）</font></li>
<li>将运输层报文段的数据交付到目的端系统正确的套接字的工作称为<font color=#DC143C>多路分解（demultiplexing）</font></li>
<li>运输层多路复用的要求：①套接字有唯一标识符；②每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些字段是<font color=#DC143C>源端口号字段字（source port number field）</font>和<font color=#DC143C>目的端口号字段（destination port number field）</font>.</li>
<li>注：主机上的每个套接字能够分诶一个端口号，而每个套接字是由应用程序所创建的。</li>
<li>一个UDP套接字是由一个二元组来全面标识的，该二元组包含<font color=#DC143C>一个目的IP地址和一个目的端口号</font>；而TCP套接字是由一个四元组来标识的，该四元组包括<font color=#DC143C>源IP地址、源端口号、目的IP地址、目的端口号</font></li>
<li>值得提及的一点，<font color=#DC143C>连接套接字和进程之间并非总是有着一一对应的关系。</font>当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可被看成是一个轻量级的子进程）</li>
</ul>
<h2 id="3-无连接运输：UDP"><a href="#3-无连接运输：UDP" class="headerlink" title="3 无连接运输：UDP"></a>3 <font color=#FF1493>无连接运输：UDP</font></h2><ul>
<li><p>为什么UDP被称为是无连接的？<br>在发送方，UDP从应用程序获得数据，附上用于多路复用/分解服务的源和目的端口号字段，然后将行程的报文段交给网络层，由网络层把该运输层报文段封装到一个IP数据报中，然后网路层将此数据报交付给接收主机；在接收方，UDP根据报文段中的目的端口号将数据交付给正确的应用程序。使用UDP时，发送方和接收方的运输层实体之间没有握手，所以<font color=#DC143C>UDP被称为是无连接的。</font></p>
</li>
<li><p>UDP不能提供可靠的数据传输服务，为何仍有用武之地？  </p>
<ul>
<li>关于何时、发送什么数据的应用层控制更为精细，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层。适用于对实时性要求较高且能容忍一些数据丢失的应用。</li>
<li>无需建立连接。如HTTP使用TCP而非UDP，是因为对于具有文本数据的Web网页来说，可靠性是关键的，但是THHP中的TCP链接建立时延对于与下载Web文档相关的时延来说是一个重要因素。</li>
<li>无连接状态。所以无需维护建立连接状态需要的参数，能够支持更多的活跃客户。</li>
<li>分组首部开销小。每个TCP报文段有20个字节的首部开销，而UDP仅有8个字节的开销。</li>
</ul>
</li>
<li><p>UDP报文段结构</p>
<center><img src="https://github.com/Bryce-HJ/IMG/raw/master/IMG/UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.jpg"  height="150">
</center> 
- UDP首部只有4个字段，每个字段由两个字节构成；
- 通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）；
- 长度字段指示了在UDP报文段中的字节数（首部加数据）；
- 检验和字段提供了差错检测功能，但是它对差错恢复毫无能力。当检查到差错时仅丢弃受损的报文段。
</li>
<li><p>UDP检验和实现：发送方的UDP报文段中对所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷，得到的结果放在UDP报文段中的检验和字段。在接受方，如果所有的16比特字（包括检验和）加在一起的16位全为1，则改分组中没有引入差错。</p>
</li>
</ul>
<h2 id="4-可靠数据传输原理"><a href="#4-可靠数据传输原理" class="headerlink" title="4 可靠数据传输原理"></a>4 <font color=#FF1493>可靠数据传输原理</font></h2><h3 id="4-1-构造可靠数据传输协议（reliable-data-transfer-potocol）"><a href="#4-1-构造可靠数据传输协议（reliable-data-transfer-potocol）" class="headerlink" title="4.1 构造可靠数据传输协议（reliable data transfer potocol）"></a>4.1 构造可靠数据传输协议（reliable data transfer potocol）</h3><ul>
<li><p>经完全可靠信道的可靠数据传输：rdt1.0<br>首先引入有限状态机（Finite-State Machine，FSM)的定义，在每一对进程中，发送方和接收方都有各自的FSM。在假定完全可靠信道的情况下，发送端送过rdt_send(data)事件接收来自较高层的数据，产生一个包含该数据的分组（经由make_pkt(data)动作），并将分组发送到信道中；在接收端，rdt通过rdt_rcv(packet)事件从底层信道接受一个分组，从分组中取出数据（经由extract（packte,data）动作），并将数据上传给较高层（通过deliver_data(data)动作）。</p>
</li>
<li><p>经具有比特差错信道的可靠数据传输：rdt2.0<br>肯定确认（positive acknowledgement）和否定确认（negative acknowledgement）控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接受有误因此需要重复，基于这样重传机制的协议称为自动重传请求（Automatic Repeat reQuest，ARQ）协议。<br>此外ARQ协议还需要另外三种协议功能来处理存在比特差错的情况：差错检测、接收方反馈（接收方向发送方回送ACK与NAK分组）、重传。值得注意的是：除非发送方确信接收方已正确接收当前分组，否则不会发送一块新的数据，由于这种行为，rdt2.0这样的协议被称为停等（stop-and-wait）协议。<br>考虑到如果接收方回送的分组产生了差错，则发送方只需重传当前数据分组即可。然而这种方法引入了冗余分组（duplicate packet）。这样使得接收方无法事先知道接收到的分组是新的还是一次重传。解决该问题的方法是在数据分组中添加一段新字段，让发送方对其数据分组编号，即将发送数据分组的序号（sequence number）放在该字段。于是，接收方只需检查序号即可确定收到的分组是否是一次重传，所以就有了如下的改进。</p>
</li>
<li><p>经具有比特差错信道的可靠数据传输：rdt2.1<br>协议rdt2.1使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认；如果收到受损的分组，则接收方将发送一个否定确认。</p>
</li>
<li><p>经具有比特差错信道的可靠数据传输：rdt2.2<br>rdt2.2是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。它与rdt2.1的区别在于，接收方此时必须包括一个由ACK报文所确认的分组序号。</p>
</li>
<li><p>经具有比特差错的丢包信道的可靠数据传输：rdt3.0<br>实现基于时间的重传机制，包含一个倒计数定时器（countdown timer），发送方没法送一个分组时便启动一个定时器，并可以相应定时器中断和终止定时器。因为分组序号在0和1之间交替，因此rdt3.0有时候被称为比特交替协议（alternative-bit protocol）。</p>
</li>
</ul>
<p>至此我们归纳一下数据传输协议的要点：<font color=#DC143C>检验和、序号、定时器、肯定和否定确认分组</font></p>
<h3 id="4-2-流水线可靠数据传输协议"><a href="#4-2-流水线可靠数据传输协议" class="headerlink" title="4.2 流水线可靠数据传输协议"></a>4.2 流水线可靠数据传输协议</h3><ul>
<li>rdt3.0协议由于是一个停等协议，所以传送数据的效率很低。解决该性能的简单方法是不使用停等协议，而采用流水线（pipelining）技术。然而流水线技术是的可靠数据传输协议<br>a. 必须增加序号范围<br>b. 协议的发送方和接收方必须缓存多个分组<br>c. 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法：回退N步和选择重传。<h3 id="4-3-回退N步（Go-Back-N-，GBN）"><a href="#4-3-回退N步（Go-Back-N-，GBN）" class="headerlink" title="4.3 回退N步（Go-Back-N ，GBN）"></a>4.3 回退N步（Go-Back-N ，GBN）</h3></li>
<li>对于发送方，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。N常被称为窗口长度（window size），GBN协议也常被称为滑动窗口协议（sliding-window protocol）。当发送窗口未满时，发送方可产生一个分组并将其发送，并相应的更新变量；当发送窗口已满时，发送方将数据返回给上层，隐式地指示上层该窗口已满。</li>
<li>在GBN协议中，对序号为n的分组的确认采用累计确认（cumulative acknowledgment），的方式，表明接收方以正确接受到序号为n的以前且包括n在内的所有分组。</li>
<li>当出现超时事件时，发送方重传所有已发送但还未被确认过得分组。</li>
<li>对于接收方，如果一个序号为n的分组被正确接收到，并且按序，则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方对其该分组，并且为最近按序接收的分组重新发送ACK。即在GBN协议中，<font color=#DC143C>接收方丢弃所有失序分组</font><h3 id="4-4-选择重传（Selective-Repeat，SR）"><a href="#4-4-选择重传（Selective-Repeat，SR）" class="headerlink" title="4.4 选择重传（Selective Repeat，SR）"></a>4.4 选择重传（Selective Repeat，SR）</h3></li>
<li>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错（即受损或丢失）的分组而避免了不必要的重传。下图分别描述了SR发送方、接收方采取的动作。  <center><img src="https://github.com/Bryce-HJ/IMG/raw/master/IMG/SR%E5%8F%91%E9%80%81%E6%96%B9.png"  height="150">
</center>
<center><img src="https://github.com/Bryce-HJ/IMG/raw/master/IMG/SR%E6%8E%A5%E6%94%B6%E6%96%B9.png" width="900" height="150">
</center> 

</li>
</ul>
<h2 id="5-面向连接的传输：TCP"><a href="#5-面向连接的传输：TCP" class="headerlink" title="5 面向连接的传输：TCP"></a>5 <font color=#FF1493>面向连接的传输：TCP</font></h2><h3 id="5-1-TCP连接"><a href="#5-1-TCP连接" class="headerlink" title="5.1 TCP连接"></a>5.1 TCP连接</h3><ul>
<li><p>TCP连接提供的是全双工服务（full-duplex service），TCP连接也总是点对点（point-to-point）的。</p>
</li>
<li><p>一旦建立起一条TCP连接，两个应用程序之间就可以相互发送数据了。客户进程通过套接字传递数据流，TCP将这些数据引导到该连接的发送缓存（send buffer）里。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度（Maximum Segment Size，MSS）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置。</p>
</li>
<li><p>TCP为每块客户数据配上一个TCP首部，从而形成了多个TCP报文段（TCP Segment）。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。</p>
</li>
<li><p>TCP连接的组成包括：一台主机上的缓存、变量、和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和进程连接的套接字。</p>
<h3 id="5-2-TCP报文段结构"><a href="#5-2-TCP报文段结构" class="headerlink" title="5.2 TCP报文段结构"></a>5.2 TCP报文段结构</h3><center><img src="https://github.com/Bryce-HJ/IMG/raw/master/IMG/TCP%E6%8A%A5%E6%96%87%E6%AE%B5.png"  height="100"></center>
</li>
<li><p>TCP报文段首部中两个最重要的字段是序号字段和确认号字段。一个报文段的序号（sequence number for a segment）是该报文段首字节的字节流编号。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p>
<h3 id="5-3-可靠数据传输"><a href="#5-3-可靠数据传输" class="headerlink" title="5.3 可靠数据传输"></a>5.3 可靠数据传输</h3></li>
<li><p>前面提到，对于已发送但未被确认的报文段都与一个定时器相关联，但TCP仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段。</p>
</li>
<li><p>TCP在每次发生超时重传时都会将下一次的超时时间间隔设为先前值的两倍，而不是用从Estimated和DevRTT推算出的值。</p>
</li>
<li><p>关于TCP的差错恢复机制，TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的；TCP实现会将正确接收但失序的报文段缓存起来。此外，选择确认（selective acknowledgment）允许TCP接收方有选择的确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。因此TCP的差错恢复机制可以被分类为GBN协议和SR协议的混合体。</p>
</li>
<li><p>TCP为他的应用程序提供了流量控制服务（flow-control service）以消除发送方是接收方缓存溢出的可能性。这里与TCP报文段首部中的接收窗口字节有关。当主机B的接收窗口为0时，主机A继续发送只要一个字节数据的报文段。</p>
<h3 id="5-4-TCP连接管理"><a href="#5-4-TCP连接管理" class="headerlink" title="5.4 TCP连接管理"></a>5.4 <font color=#FF1493>TCP连接管理</font></h3></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2020/03/12/%E8%BF%90%E8%BE%93%E5%B1%82/" data-id="ck7pmqoxk000078sg234z2sua" class="article-share-link">分享到</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/02/15/MarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%C2%B7%C2%B7%C2%B7%C2%B7%C2%B7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MarkDown语法总结，持续更新中·····</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 郝靖<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>